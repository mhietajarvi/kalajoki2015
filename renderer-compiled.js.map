{"version":3,"sources":["renderer.js"],"names":[],"mappings":";;;AAGA,YAAY,CAAC;;;;;;IAEP,MAAM,GAEG,SAFT,MAAM,CAEI,IAAI,EAAE;0BAFhB,MAAM;;AAGJ,QAAI,CAAC,IAAI,GAAG,IAAI,CAAC;CACpB;;IAKC,eAAe;AAEN,aAFT,eAAe,CAEL,OAAO,EAAE,MAAM,EAAE,kBAAkB,EAAE,iBAAiB,EAAE;8BAFlE,eAAe;;AAGb,YAAI,CAAC,OAAO,GAAG,OAAO,CAAC;AACvB,YAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACrB,YAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;AAC7C,YAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;KAC9C;;;;iBAPC,eAAe;;eAUX,gBAAC,KAAK,EAAE;AACV,8BAAkB,CAAC,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AACnD,6BAAiB,CAAC,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AAClD,gBAAI,MAAM,GAAG,IAAI,MAAM,CAAC,OAAO,EAAE,kBAAkB,EAC/C,iBAAiB,EAAE,KAAK,CAAC,CAAC;;;;;;;;;;;;;AAc9B,gBAAI,CAAC,CAAC;AACN,gBAAI,CAAC,CAAC;AACN,gBAAI,YAAY,GAAG,IAAI,YAAY,EAAE,CAAC;;;;;;AAMtC,gBAAI,MAAM,CAAC;;AAEX,mBAAO,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE;;;AAG7C,oBAAI,UAAU,GAAG,MAAM,CAAC,uBAAuB,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AAC7D,mBAAG,CAAC,kBAAkB,CAAC,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC,CAAC;;AAEnE,oBAAI,UAAU,GAAG,CAAC,EAAE;AAChB,qBAAC,GAAG,UAAU,GAAG,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,YAAY,EAAE,CAAC,CAAC,CAAC;iBAClF,MAAM;AACH,qBAAC,GAAG,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,CAAC,CAAC;AACZ,qBAAC,GAAG,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,CAAC,CAAC;iBACf;;;aAGJ;;AAGD,kBAAM,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAA;;;;;;;;;;SAYzC;;;;;eAGC,YAAC,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,SAAS,EAAE,YAAY,EAAE,EAE3D;;;;;eAGY,uBAAC,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,EAE7C;;;WA7EC,eAAe","file":"renderer-compiled.js","sourcesContent":["/**\r\n * Created by Matti on 23.9.2015.\r\n */\r\n\"use strict\";\r\n\r\nclass Camera {\r\n\r\n    constructor(film) {\r\n        this.film = film;\r\n    }\r\n\r\n\r\n}\r\n\r\nclass SamplerRenderer {\r\n\r\n    constructor(sampler, camera, surface_integrator, volume_integrator) {\r\n        this.sampler = sampler;\r\n        this.camera = camera;\r\n        this.surface_integrator = surface_integrator;\r\n        this.volume_integrator = volume_integrator;\r\n    }\r\n\r\n    // return true and fill in intersection if intersection found\r\n    render(scene) {\r\n        surface_integrator.preprocess(scene, camera, this);\r\n        volume_integrator.preprocess(scene, camera, this);\r\n        var sample = new Sample(sampler, surface_integrator,\r\n            volume_integrator, scene);\r\n\r\n        // launch tasks (later)\r\n\r\n        // for now just run single task here\r\n\r\n\r\n        // Get sub-Sampler for SamplerRendererTask\r\n        // Declare local variables used for rendering loop\r\n\r\n        // Allocate space for samples and intersections\r\n        //int maxSamples = sampler->MaximumSampleCount();\r\n        //Sample *samples = origSample->Duplicate(maxSamples);\r\n        //RayDifferential *rays = new RayDifferential[maxSamples];\r\n        var L; //= new Spectrum();\r\n        var T; //= new Spectrum();\r\n        var intersection = new Intersection();\r\n        //Intersection *isects = new Intersection[maxSamples]\r\n        //\r\n\r\n        // simplify for now by doing thing one sample at a time\r\n\r\n        var sample;\r\n\r\n        while (sample = this.sampler.getNextSample(rng)) {\r\n            // Generate camera ray and compute radiance along ray\r\n            // - Find camera ray for sample[i]\r\n            var ray_weight = camera.generateRayDifferential(sample, ray);\r\n            ray.scaleDifferentials(1.0 / Math.sqrt(sampler.samples_per_pixel));\r\n            // - Evaluate radiance along camera ray\r\n            if (ray_weight > 0) {\r\n                L = ray_weight * this.li(this.scene, ray, sample, rng, arena, intersection, T);\r\n            } else {\r\n                L = [0,0,0];\r\n                T = [1,1,1];\r\n            }\r\n            // Report sample results to Sampler, add contributions to image\r\n            // Free MemoryArena memory from computing image sample values\r\n        }\r\n\r\n\r\n        camera.generateRayDifferential(sample)\r\n        // Get samples from Sampler and update image\r\n        //int sampleCount;\r\n        //while ((sampleCount = sampler->GetMoreSamples(samples, rng)) > 0) {\r\n        //Generate camera rays and compute radiance along rays\r\n        //Report sample results to Sampler, add contributions to image\r\n        //Free MemoryArena memory from computing image sample values\r\n        //}\r\n\r\n        // Clean up after SamplerRendererTask is done with its image region\r\n\r\n\r\n    }\r\n\r\n    // return Spectrum\r\n    li(scene, ray, sample, rng, arena, isect_out, spectrum_out) {\r\n\r\n    }\r\n\r\n    // return Spectrum\r\n    transmittance(scene, ray, sample, rng, arena) {\r\n\r\n    }\r\n\r\n}"]}